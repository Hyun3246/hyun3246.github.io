---
title:  "[MIT 데이터 사이언스 기초] Chapter 4. Stochastic Thinking"
excerpt: "확률과 이를 구하는 강력한 방법인 시뮬레이션 모델"

categories:
  - Data Science
tags:
  - [Data Science, 확률, 시뮬레이션]

use_math: true
toc: true
toc_sticky: true
 
date: 2023-02-13
last_modified_at: 2023-03-01

header:
  overlay_image: /image/overlay image/mit data science.png
  overlay_filter: 0.5
---

이번 강은 앞선 강좌와는 조금 다르게 '확률'을 주제로 진행된다.

## 뉴턴역학  VS 불확정성 원리
사실 이 부분은 인트로에 지나지 않으나, 확률이 실생활을 이해하는 데 왜 중요한지를 알 수 있는 부분이다.    

뉴턴 역학은 모든 결과에 원인이 존재한다고 가정한다. 세계는 인과관계로 이해될 수 있다.   
그러나 코펜하겐 불확정성 원리는 가장 근본적인 단계에서, 물리적 세계의 행동은 예측할 수 없다고 주장한다. 즉 반드시 일어나는, 확률이 1인 사건은 존재하지 않는 것이다.     

예를 들어, 동전 2개를 던졌을 때, 어떤 면이 위를 향해 있는지를 예측해보라고 하면, 섣불리 답하기 쉽지 않다. 결국 우리는 완벽한 예측 대신 확률에 의존해 조금이라도 더 가능성이 높은 결과를 답으로 내놓는다.    

세계에 대한 예측도 마찬가지다. 미래에 일어날 일을 정확히 예측할 수는 없다. 그래서 우리는 '확률'이라는 도구를 활용해 조금이라도 더 정확하게 예측하고자 노력할 수밖에 없다.   
<br/>

## 확률
매우 간단한 이야기지만(그리고 중학교만 나와도 다 아는 사실이지만), 확률에서 중요하게 다루어지는 세 가지 사실이 있다.    
1. 확률은 항상 0에서 1 사이이다.
2. 어떤 사건이 일어날 확률이 p라면, 일어나지 않을 확률은 (1-p)이다. (여사건)
3. **사건들이 서로 독립이라면**, 모든 사건이 동시에 일어날 확률은 각 사건이 일어날 확률의 곱과 같다.(곱의 법칙)   

3번은 특히 주의가 필요한데, 독립이라는 가정 하에서만 성립하기 때문이다.     

[관련 코드 보러가기](https://github.com/Hyun3246/Code-Warehouse/tree/main/MIT%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4%20%EA%B8%B0%EC%B4%88)   
<br/>
> cf. 확률을 알아보기 위해 작성한 파이썬 코드에서는 `random.choice`를 활용한다. 그러나 이는 실제로 랜덤하게 숫자를 고르는 것이 아니라, 시작점만 랜덤하게 잡고 이후에는 일정한 규칙에 따라 숫자를 고른다. 즉, `random.seed(0)`을 활용해 시작점을 고정하면 항상 같은 값만 출력하는 것이다.   
교수님을 이러한 성질을 활용해 수학적 확률과 추정 확률을 따로 구하였다. 
<br/>

해당 코딩으로부터 얻은 교훈은 다음과 같다.  
1. 매우 많은 시도만이 좋은 추정을 도출할 수 있다.
2. 표본으로부터 추정한 확률 $\neq$ 실제 확률
3. 시뮬레이션은 완벽하진 않지만 유용하다.

<br/>

## 생일문제
초등학교에서 다루는 매우 친근한 문제이다. 일정한 무리가 있을 때, 생일이 같은 사람이 있을 확률은?    
결과도 기억이 잘 난다. '그럴 확률은 매우 높다.'

먼저 최소한 두 명의 생일이 같을 확률을 구할 수 있다. 수학적으로는 여사건을 사용한다.    

$$1 - \frac{366!}{366^n \times (366-N)!}$$    

물론 N은 366보다는 작아야 한다. 아니면 비둘기집의 원리에 의해 (계산할 필요도 없이) 무조건 생일이 같은 사람이 나온다.    

그런데 시뮬레이션(코딩)에서는 이러한 공식을 사용하지 않는다! 아이디어는 다음과 같다.    
1. 가능한 날짜(1~366)를 설정한다.
2. 366개의 0으로 이루어진 리스트를 만든다. 각각 숫자는 해당 날짜에 생일자인 사람 수를 나타낸다.
3. 1에서 설정한 날짜 중에서 랜덤하게 하나를 뽑고, 리스트의 해당 인덱스의 숫자를 1 증가시킨다.

[관련 코드 보러가기](https://github.com/Hyun3246/Code-Warehouse/tree/main/MIT%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4%20%EA%B8%B0%EC%B4%88)

이렇게 하면 최종적으로 0으로 이루어졌던 리스트는 각 날짜에 생일인 사람 수를 나타내는 리스트로 바뀌게 된다. 확률은 그 다음에 간단하게 구할 수 있다.      

지금은 시뮬레이션 프로그램이 수학 공식에 비해 그렇게 강력하지 않아 보일 수 있다. 그러나 질문이 바뀌면 상황이 달라진다.     

'세 명이 같은 생일을 공유할 확률은?'    

이 문제를 수학 공식으로 해결하기는 쉽지 않다. 단순히 두 개의 경우만 있는 상황은 여사건으로 간단하게 풀 수 있지만, 3개부터는 생각할 요소가 많아지기 때문이다.    
그러나 시뮬레이션 프로그램은 이미 모든 날짜에 대한 생일자 수를 구해놓았다. 우리가 활용하지만 않았을 뿐. 사람 수가 늘어나도 함수에 대입하는 인자만을 바꿔주면 된다. 나머지는 그대로 둬도 결과를 내는 데는 아무 지장이 없다.      
날짜에 대한 정보를 바꿔야 할 때도 시뮬레이션은 강력하다. 1에서 설정한 가능한 날짜를 수정만 하면 된다.       
<br/>

시뮬레이션은 본질적으로 완벽하지 않다. 최적화 모델처럼 그 계산 과정을 상세히 설명하지도 않는다. 그러나 조지 박스(Geroge Box)의 말처럼, 시뮬레이션은 꽤나 쓸만하다.
